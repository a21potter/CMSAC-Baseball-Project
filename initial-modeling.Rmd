---
title: "Initial Modeling"
author: "Amber Potter & Nicholas Esposito"
date: "7/23/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load libraries and data
```{r}
library(baseballr)
library(glue)
library(tidyverse)
library(knitr)
library(ranger)
```

```{r}
statcast_data <- read_rds("data/statcast_data_clean.rds")

names(statcast_data)[1] <- 'pitch_id'
```

# Filter out 2020 and 2022 seasons
 
```{r}
statcast_data_minus_2020_2022 <- statcast_data %>%
  filter(!(game_year %in% c(2020, 2022)))
```


# Reclassifying pitch type

```{r, warning = FALSE, message = FALSE}
statcast_data_minus_2020_2022 <- statcast_data_minus_2020_2022 %>%
  filter(!is.na(pitch_type)) %>%
  mutate(general_pitch_type = fct_recode(as.factor(pitch_type),
                                        "Breaking Ball" = "CU",
                                        "Fastball" = "FF",
                                        "Breaking Ball" = "SL",
                                        "Fastball" = "SI",
                                        "Changeup" = "CH",
                                        "Breaking Ball" = "KC",
                                        "Fastball" = "FC",
                                        "Fastball" = "FS",
                                        "Non-Pitch" = "IN",
                                        "Breaking Ball" = "FO",
                                        "Other" = "",
                                        "Changeup" = "EP",
                                        "Knuckle Ball" = "KN",
                                        "Non-Pitch" = "PO",
                                        "Fastball" = "FA",
                                        "Breaking Ball" = "SC",
                                        "Breaking Ball" = "CS"))
```

# Create an indicator for the last pitch of an at-bat

```{r}
statcast_data_minus_2020_2022 <- statcast_data_minus_2020_2022 %>%
  group_by(game_id, batter, at_bat_number) %>%
  #arrange(pitch_number) %>%
  mutate(pitch_count = max(pitch_number),
         last_pitch_of_at_bat = case_when(pitch_number == pitch_count ~ TRUE,
                                          TRUE ~ FALSE)) %>%
  ungroup()
```

# 200+ at bats (overall)

```{r}
statcast_data_minus_2020_2022 <- statcast_data_minus_2020_2022 %>%
  group_by(game_year, batter, stand) %>%
  mutate(total_player_at_bats = length(which(last_pitch_of_at_bat == TRUE))) %>%
  filter(total_player_at_bats >= 200)
```

## Strikeout labels

```{r}
statcast_data_minus_2020_2022 <- statcast_data_minus_2020_2022 %>%
  mutate(pitch_outcome = case_when(events != "" ~ events,
                                   events == "" ~ description)) %>%
  mutate(pitch_outcome = case_when(events == "strikeout" & description == "swinging_strike" ~ "strikeout_swinging",
                                   events == "strikeout" & description == "called_strike" ~ "strikeout_called",
                                   events == "strikeout" & !(description %in% c("swinging_strike", "called_strike")) ~ paste0("strikeout_other"),
                                   TRUE ~ pitch_outcome))
```


# Filter out NA values in each field alignment category, extreme outfield shift, and spring training/exhibition games

```{r}
statcast_data_minus_2020_2022 <- statcast_data_minus_2020_2022 %>%
  filter(if_fielding_alignment != "", !of_fielding_alignment %in% c("", "Extreme outfield shift"), 
         !game_type %in% c("S", "E")) # Filter NAs, ex. outfield shift, and ST/E games
```

# Filter out potential infield-in situations

```{r}
statcast_data_minus_2020_2022 <- statcast_data_minus_2020_2022 %>%
  filter(!(on_3b != "" & outs_when_up < 2 & if_fielding_alignment == "Shift"))
```

# Reduce shifting categories to shift vs standard

```{r}
statcast_data_minus_2020_2022 <- statcast_data_minus_2020_2022 %>%
  mutate(general_fielding_alignment = 
           case_when(if_fielding_alignment == "Infield shift" |
                       of_fielding_alignment == "4th outfielder" ~ "Shift",
                     TRUE ~ "Standard"))

# Reduce shifting subcategories to Standard vs Shift
statcast_data_minus_2020_2022 <- statcast_data_minus_2020_2022 %>%
  mutate(if_fielding_alignment = 
           case_when(if_fielding_alignment == "Infield shift" ~ "Shift",
                     if_fielding_alignment == "Strategic" |
                       if_fielding_alignment == "Standard"~ "Standard")) %>%
  mutate(of_fielding_alignment = 
           case_when(of_fielding_alignment == "4th outfielder" ~ "Shift",
                     of_fielding_alignment == "Strategic" |
                       of_fielding_alignment == "Standard" ~ "Standard"))
```

# Adjust BABIP calculation to exclude NAs and variables not involved in finding BABIP

```{r}
statcast_data_minus_2020_2022 <- statcast_data_minus_2020_2022 %>%
  mutate(babip_value_with_NAs = case_when(last_pitch_of_at_bat == FALSE | events == "sac_bunt_double_play" | events == "sac_bunt" | events == "home_run" | description != "hit_into_play" ~ NA_real_,
                                          TRUE ~ babip_value))
```


```{r}
statcast_data_minus_2020_2022 <- statcast_data_minus_2020_2022 %>%
#  filter(last_pitch_of_at_bat == TRUE) %>%
  mutate(walk = case_when(events == "walk" ~ 1,
                          TRUE ~ 0),
         strikeout = case_when(events == "strikeout" ~ 1,
                               TRUE ~ 0)) %>%
  group_by(game_year, batter, stand, if_fielding_alignment) %>%
  mutate(bb_rate = sum(walk) / length(which(last_pitch_of_at_bat == TRUE)),
            k_rate = sum(strikeout) / length(which(last_pitch_of_at_bat == TRUE)),
            babip = mean(babip_value_with_NAs, na.rm = TRUE),
            woba = sum(woba_value, na.rm = TRUE) / length(which(last_pitch_of_at_bat == TRUE))) %>%
  ungroup()
```

# Training set

```{r}
statcast_data_minus_2020_2022 <- statcast_data_minus_2020_2022 %>%
  mutate(batter_instance_identifier = paste(batter, game_year, stand, if_fielding_alignment, sep = ":")) 
    
statcast_training_data_rf_identifiers <- statcast_data_minus_2020_2022 %>%
  select(game_year, batter, stand, if_fielding_alignment, batter_instance_identifier) %>%
  unique() %>%
  group_by(game_year, stand, if_fielding_alignment) %>%
  sample_frac(.2)

statcast_training_data <- statcast_data_minus_2020_2022 %>%
  filter(batter_instance_identifier %in% statcast_training_data_rf_identifiers$batter_instance_identifier)
```


# At-bat level data

```{r}
statcast_data_at_bats_minus_2020_2022 <- statcast_data_minus_2020_2022 %>%
  filter(last_pitch_of_at_bat == TRUE)

unique(statcast_data_at_bats_minus_2020_2022$pitch_type)
```


## Variables as factors - SHOULD WE FORMAT MIDDLE NUMBERS (2,5,8) IN SAME WAY (M#?)

```{r}
statcast_data_at_bats_minus_2020_2022 <- statcast_data_at_bats_minus_2020_2022 %>%
  mutate(game_year = as.factor(game_year),
         batter = as.factor(batter),
         pitcher = as.factor(pitcher)) %>%
         #zone = as.factor(zone)) %>%
  mutate(stand = factor(stand, levels = c("R", "L")),
         p_throws = factor(p_throws, levels = c("R", "L")),
         general_pitch_type = factor(general_pitch_type, levels = c("Fastball", "Breaking Ball", "Changeup", "Knuckle Ball")),
         if_fielding_alignment = factor(if_fielding_alignment, levels = c("Standard", "Shift")))
```

## Remove non-pitches

```{r}
statcast_data_at_bats_minus_2020_2022 <-statcast_data_at_bats_minus_2020_2022 %>%
  filter(general_pitch_type != "Non-Pitch")
```



## Fix zones

```{r}
statcast_data_at_bats_minus_2020_2022 <- statcast_data_at_bats_minus_2020_2022 %>%
  #mutate(zone = as.numeric(zone)) %>%
  mutate(zone_new = case_when(stand == "L" & zone %in% c(1, 4, 7) ~ zone + 2,
                          stand == "L" & zone %in% c(11, 13) ~ zone + 2,
                          stand == "L" & zone %in% c(3, 6, 9) ~ zone - 2,
                          stand == "L" & zone %in% c(12, 14) ~ zone - 2,
                          TRUE ~ zone)) %>%
  mutate(zone_simp = case_when(zone_new %in% c(1, 4, 7) ~ "Inside",
                               zone_new %in% c(2, 5, 8) ~ "Middle",
                               zone_new %in% c(3, 6, 9) ~ "Outside",
                               TRUE ~ "Out of Zone")) %>%
  select(- zone_new) %>%
  mutate(zone = as.factor(zone))

```

## Delta wOBA

```{r}
delta_woba_vector <- statcast_data_at_bats_minus_2020_2022 %>%
  group_by(game_year, batter, stand) %>%
  select(batter_instance_identifier, woba, total_player_at_bats) %>%
  unique() %>%
  mutate(count = n()) %>%
  filter(count == 2) %>%
  arrange(batter_instance_identifier) %>%
  # delta woba
  mutate(delta_woba = lead(woba) - woba) %>%
  mutate(delta_woba = ifelse(is.na(delta_woba), lag(delta_woba), delta_woba)) %>%
  mutate(batter_identifier = paste(batter, game_year, stand, sep = ":")) %>%
  # harmonic mean delta woba
  mutate(harmonic_mean_delta_woba = ((2 * total_player_at_bats * lead(total_player_at_bats)) / total_player_at_bats + lead(total_player_at_bats)) * delta_woba) %>%
  mutate(harmonic_mean_delta_woba = ifelse(is.na(harmonic_mean_delta_woba), lag(harmonic_mean_delta_woba), harmonic_mean_delta_woba)) %>%
  select(batter_identifier, delta_woba, harmonic_mean_delta_woba) 





  

statcast_data_at_bats_minus_2020_2022_woba <- statcast_data_at_bats_minus_2020_2022 %>%
  mutate(batter_identifier = paste(batter, game_year, stand, sep = ":")) %>%
  left_join(delta_woba_vector, by = c("batter_identifier" = "batter_identifier", "game_year" = "game_year", "batter" = "batter", "stand" = "stand")) %>%
  select(pitch_id, batter, events, description, stand, p_throws, game_year, hit_distance_sc, launch_speed, launch_angle, if_fielding_alignment, pitch_outcome, game_id, general_pitch_type, total_player_at_bats, bb_rate, k_rate, babip, woba_value, woba, zone_simp, delta_woba, harmonic_mean_delta_woba) %>%
  unique()
```

## Binary At-Bat Outcome

```{r}
statcast_data_at_bats_minus_2020_2022_woba <- statcast_data_at_bats_minus_2020_2022_woba %>%
  mutate(on_base_binary = case_when(woba_value == 0 ~ 0,
                                    TRUE ~ 1))
```


## Write modified dataset as RDS

```{r}
write_rds(statcast_data_at_bats_minus_2020_2022_woba, "data/statcast_at_bat_model_data.rds", compress = "gz")
```


## Read data

```{r}
statcast_model_data <- read_rds("data/statcast_at_bat_model_data.rds")
```



# Basic Linear Model

```{r}
init_linear_model <- lm(woba_value ~ general_pitch_type + 
                          game_year + 
                          if_fielding_alignment + 
                          zone_simp + 
                          stand+ 
                          p_throws+ 
                          woba + 
                          p_throws * stand * if_fielding_alignment + 
                          zone_simp * if_fielding_alignment * general_pitch_type, 
                        data = statcast_model_data)


summary(init_linear_model)
```


## Initial Logistic Model 

```{r}
init_logistic_model <- glm(on_base_binary ~ general_pitch_type + 
                          game_year + 
                          if_fielding_alignment + 
                          zone_simp + 
                          stand + 
                          p_throws+ 
                          harmonic_mean_delta_woba + 
                          p_throws * stand * if_fielding_alignment, 
                        data = statcast_model_data, 
                        family = "binomial")

summary(init_logistic_model)

```

## Checking Linearity Assumption

```{r}
statcast_data_at_bats_minus_2020_2022 %>%
  count(general_pitch_type, game_year, if_fielding_alignment, zone_simp, stand, p_throws) %>%
  #group_by(currentSmoker) %>%
  mutate(prop = n/sum(n)) %>%
  #filter(high_risk == "1") %>%
  mutate(emp_logit = log(prop/(1-prop)))
```


```{r}
library(ggfortify)
autoplot(init_logistic_model, which = 4, ncol = 1)

### Looking at multicolinearity
library(rms)
vif(init_logistic_model) %>%
  kable()

init_logistic_model$linear.predictors

### Checking linearity condition ---
library(Stat2Data)
emplogitplot1(on_base_binary ~ harmonic_mean_delta_woba, data = statcast_data_at_bats_minus_2020_2022_woba, 
              ngroups = 10)
```

```{r}
statcast_data_at_bats_minus_2020_2022_woba %>%
  ungroup() %>%
  select(on_base_binary, harmonic_mean_delta_woba, general_pitch_type, game_year, if_fielding_alignment, zone_simp, stand, p_throws) %>%
  na.omit() %>%
  mutate(pred_prob = init_logistic_model$fitted.values) %>%
  ggplot(aes(x = init_logistic_model$linear.predictors)) +
  geom_point(aes(y = pred_prob), 
            color = "blue") +
  geom_point(aes(y = on_base_binary), 
             alpha = 0.05,
             color = "darkorange") +
  theme_bw()

library(patchwork)
library(ggeffects)
plts = lapply(names(coefficients(init_logistic_model))[-1],function(i){
       return(plot(ggpredict(init_logistic_model,i)))
       })

wrap_plots(plts)

statcast_data_at_bats_minus_2020_2022_woba %>%
  group_by(batter, game_year, stand) %>%
  count(on_base_binary) %>%
  select()
```



```{r}
statcast_model_data %>%
  ungroup() %>%
  drop_na(delta_woba) %>%
  mutate(pred_prob = init_logistic_model$fitted.values,
         bin_pred_prob = round(pred_prob / 0.01) * .01) %>%
  # Group by bin_pred_prob:
  group_by(bin_pred_prob) %>%
  # Calculate the calibration results:
  summarise(n_attempts = n(),
            bin_actual_prob = mean(on_base_binary)) %>%
  ggplot(aes(x = bin_pred_prob, y = bin_actual_prob)) +
  geom_point(aes(size = n_attempts)) +
  geom_smooth(method = "loess", se = FALSE) +
  geom_abline(slope = 1, intercept = 0, 
              color = "black", linetype = "dashed") +
  #facet_wrap(~ if_fielding_alignment) +
  coord_equal() + 
  scale_x_continuous(limits = c(.2,.5)) + 
  scale_y_continuous(limits = c(.2,.5)) + 
  labs(size = "Number of At-Bats",
       x = "Estimated Probability of Getting On Base",
       y = "Observed Probability of Getting On Base") + 
  theme_bw() +
  theme(legend.position = "bottom")
```


```{r}
statcast_model_data %>%
  ungroup() %>%
  drop_na(delta_woba) %>%
  mutate(pred_prob = init_logistic_model$fitted.values,
         bin_pred_prob = round(pred_prob / 0.01) * .01) %>%
  # Group by bin_pred_prob:
  group_by(stand, bin_pred_prob) %>%
  # Calculate the calibration results:
  summarise(n_attempts = n(),
            bin_actual_prob = mean(on_base_binary)) %>%
  ggplot(aes(x = bin_pred_prob, y = bin_actual_prob)) +
  geom_point(aes(size = n_attempts)) +
  geom_smooth(method = "loess", se = FALSE) +
  geom_abline(slope = 1, intercept = 0, 
              color = "black", linetype = "dashed") +
  facet_wrap(~ stand) +
  coord_equal() + 
  scale_x_continuous(limits = c(.2,.5)) + 
  scale_y_continuous(limits = c(.2,.5)) + 
  labs(size = "Number of At-Bats",
       x = "Estimated Probability of Getting On Base",
       y = "Observed Probability of Getting On Base") + 
  theme_bw() +
  theme(legend.position = "bottom")
```


### Why the three groups?

```{r}
statcast_model_data %>%
  ungroup() %>% 
  drop_na(delta_woba) %>%
  mutate(predicted_on_base_probability = init_logistic_model$fitted.values) %>%
  #group_by(zone_simp) %>%
  summarize(residual = on_base_binary - predicted_on_base_probability,
            general_pitch_type) %>%
  group_by(general_pitch_type) %>%
  summarize(avg_residual = mean(residual))
```










```{r}
statcast_model_data %>%
  ungroup() %>% 
  drop_na(delta_woba) %>%
  mutate(predicted_on_base_probability = init_logistic_model$fitted.values) %>%
  group_by(game_year) %>%
  #count()
  ggplot(aes(x = predicted_on_base_probability, y = on_base_binary, color = if_fielding_alignment)) +
  geom_point(alpha = .1) + 
  facet_wrap(game_year ~ stand)
```


Assumption #1: The Response Variable is Binary, Yes

Assumption #2: The Observations are Independent, Not quite

Assumption #3: There is No Multicollinearity Among Explanatory Variables, no multicolinearity

Assumption #4: There are No Extreme Outliers

Assumption #5: There is a Linear Relationship Between Explanatory Variables and the Logit of the Response Variable ???

Assumption #6: The Sample Size is Sufficiently Large

```{r}
ggplot(data = statcast_data_at_bats_minus_2020_2022, aes(x = harmonic_mean_delta_woba)) +
  geom_histogram()
```















When shifting takes place, how is wOBA affected?

control for shifting, batter info, pitcher info, handedness

Controlling for ability of hitter (batter's wOBA) -> this is the outcome on wOBA

mixed effects -> batter/pitcher

coeff. estimate for shifts

formal inference (use whole data for learning) 

pitch type driving changes? easier for righties to hit righty CBs

Use last pitch of at-bat (modeling at at-bat level!)